### 创建线程的两种方式分别是什么？各有什么优缺点？

```
- 继承Thread类：优点是Thread类的子类对象就是线程对象，具有Thread类声明的方法，并且具有线程体，缺点是不适用于多继承。
- 实现Runnable接口：当一个类已经继承一个父类的时候，还要以线程方式运行时，就需要实现Runnable接口。实现了Runnable接口的对象不是线程对象，是线程对象的目标对象，所以还需要将其传入一个Thread类的线程对象。
```



### 5.请你简述sleep( )和wait( )有什么区别？

```
sleep() 方法是线程类（Thread）的静态方法，让调用线程进入睡眠状态，让出执行机会给其他线程，等到休眠时间结束后，线程进入就绪状态和其他线程一起竞争cpu的执行时间。
因为sleep() 是static静态的方法，他不能改变对象的机锁，当一个synchronized块中调用了sleep() 方法，线程虽然进入休眠，但是对象的机锁没有被释放，其他线程依然无法访问这个对象。

wait()是Object类的方法，当一个线程执行到wait方法时，它就进入到一个和该对象相关的等待池，同时释放对象的机锁，使得其他线程能够访问，可以通过notify，notifyAll方法来唤醒等待的线程
```



### 6.Java中实现线程通信的三个方法及其作用？

```
同步方法，同步代码块，lock锁
```



### 7.现在有线程 T1、T2 和 T3。你如何确保 T2 线程在 T1 之后执行，并且 T3 线程在 T2 之后执行？

```
创建一个活跃线程数的线程池，顺序调用submit（）方法即可
```



### 8.Java 中新的 Lock 接口相对于同步代码块（synchronized block）有什么优势？如果让你实现一个高性能缓存，支持并发读取和单一写入，你如何保证数据完整性。

```
lock在代码量多的时候方便上锁和解锁，而同步代码块中存在大量代码时并不理想
```



### 9.Java 中 wait 和 sleep 方法有什么区别？

```
sleep() 方法是线程类（Thread）的静态方法，让调用线程进入睡眠状态，让出执行机会给其他线程，等到休眠时间结束后，线程进入就绪状态和其他线程一起竞争cpu的执行时间。
因为sleep() 是static静态的方法，他不能改变对象的机锁，当一个synchronized块中调用了sleep() 方法，线程虽然进入休眠，但是对象的机锁没有被释放，其他线程依然无法访问这个对象。

wait()是Object类的方法，当一个线程执行到wait方法时，它就进入到一个和该对象相关的等待池，同时释放对象的机锁，使得其他线程能够访问，可以通过notify，notifyAll方法来唤醒等待的线程
```





### 10.如何在 Java 中编写代码解决生产者消费者问题

```
消费者线程先wait（），等待生产者生产好商品之后自身等待，notify（）唤醒消费者线程，进行消费，消费完再自身等待，唤醒生产者生产商品
```



### 11.写一段死锁代码。你在 Java 中如何解决死锁？

```
1.多层嵌套同步代码块
解决方案：对锁进行排序，使得每次获取锁的顺序一致
2.同步代码块中调用同步方法
解决方案：尽量不在同步代码块中调用同步方法
```



### 12.什么是原子操作？Java 中有哪些原子操作

```
"原子操作(atomic operation)是不需要synchronized"，所谓原子操作是指不会被线程调度机制打断的操作；这种操作一旦开始，就一直运行到结束，中间不会有任何 context switch；

java中一般事务管理里面用到原子操作。
```



### 13.既然 start() 方法会调用 run() 方法，为什么我们调用 start() 方法，而不直接调用 run() 方法

```
start()方法是通知Java虚拟机，开辟一个新的线程，并且在新的线程中加载线程中的所有方法以及变量，自动调用run（）方法执行。
```

### Java中List<?>和List之间的区别是什么？Java中List和原始类型List之间的区别？

```
这个不知道
```



### Java中synchronized 和 ReentrantLock 有什么不同？

```
1）Lock是一个接口，synchronized是Java中的关键字，synchronized是内置的语言实现；
2)synchronized发生异常时，会自动释放线程占用的锁，故不会发生死锁现象。Lock发生异常，若没有主动释放，极有可能造成死锁，故需要在finally中调用unLock方法释放锁；
3)Lock可以让等待锁的线程响应中断，使用synchronized只会让等待的线程一直等待下去，不能响应中断
4)通过Lock可以知道有没有成功获取到锁，synchronized就不灵
5)Lock可以提高多个线程进行读操作的效率
```



### 并发编程的三要素

### ConcurrentHashMap和Hashtable的区别？